---
title: "An early look at Dagger Reflect"
date: 2019-09-30T10:00:00.000+02:00
draft: false
aliases: ["/2019/09/an-early-look-at-dagger-reflect.html"]
tags:
  [
    Dagger-Reflect,
    Java,
    Annotation processor,
    Dagger 2,
    Dagger-Android,
    Gradle,
    Kotlin,
    Android,
    Reflection,
  ]
author: "Stavro Xhardha"
---

[![](https://1.bp.blogspot.com/-YvDnvin3OvI/XY0XCR1ATTI/AAAAAAAAPdQ/j6ccKjaxeo8o7E32VdeNR3vUG2B4jlwUACLcBGAsYHQ/s1600/garrett-parker-DlkF4-dbCOU-unsplash.jpg)](https://1.bp.blogspot.com/-YvDnvin3OvI/XY0XCR1ATTI/AAAAAAAAPdQ/j6ccKjaxeo8o7E32VdeNR3vUG2B4jlwUACLcBGAsYHQ/s1600/garrett-parker-DlkF4-dbCOU-unsplash.jpg)

When it comes to solving the Dependency Inversion principle, there is no better way then using annotations in the JVM world. However, generating code in compile time has some costs. For example the build time. And I believe this is the only thing dagger can't do well alone.

_This is not a bye bye dagger post. This is mostly, obtaining the most out of Dagger._  
To solve this problem, [Dagger-Reflect](https://github.com/JakeWharton/dagger-reflect) was written. What this tool does, is basically moving Dagger a step forward, from code generation at compile time, to code generation at Runtime, which basically is what reflection does, overall.

To set up Dagger-Reflect is pretty easy. Just add these lines to your build.gradle (module app) file:

```kotlin
dependencies {
  if (properties.containsKey('android.injected.invoked.from.ide')) {
    debugAnnotationProcessor 'com.jakewharton.dagger:dagger-reflect-compiler:0.1.0'
    debugApi 'com.jakewharton.dagger:dagger-reflect:0.1.0' // or debugImplementation
  } else {
    debugAnnotationProcessor "com.google.dagger:dagger-compiler:$daggerVersion"
  }
  releaseAnnotationProcessor "com.google.dagger:dagger-compiler:$daggerVersion"
  api "com.google.dagger:dagger:$daggerVersion" // or implementation
}
```

You can check the docs for full or partial configuration. One thing that doesn't go well with this configuration is repetitive code if you have a lot of modules. Yes, you have to do this in every module that you have dagger. Therefore, there is already a plugin which handles that, and requires only a small configuration from you. Just add these lines of code in your build.gradle (module project) file:

```kotlin
 buildScript{
 ...
  dependencies {
   ...
   classpath 'com.soundcloud.delect:delect-plugin:0.1.0'
  }
}

apply plugin: 'com.soundcloud.delect'
```

Another small step is to addÂ dagger.reflect = true , in your gradle.properties and you are good to go.

The usage of Dagger-Reflect is pretty simple. Instead ofÂ DaggerMyAwesomeAppComponent.factory().create(this), you should addÂ DaggerReflect.factory(MyAwesomeAppComponent.Factory::class.java).create(this).

_Notes to keep in mind:Â _  
_1- Your component must have a builder or a factory._  
_2- If you have annotations like @Qualifier (in my case, I don't) must have the runtime policyÂ @Retention(RUNTIME)_  
_3 - Should apply the reflection for every component in your application (In my case I have only one component)_

Here is the result for the build time:

[![](https://1.bp.blogspot.com/-Hn4hfUSt6TA/XYzVg3drzXI/AAAAAAAAPdE/n9KtXiFL55khq2wXnenPsWHoMFH8AQ8bQCEwYBhgL/s1600/Dagger%2Bwithout%2BReflection%2Band%2BDagger%2Bwith%2BReflection.png)](https://1.bp.blogspot.com/-Hn4hfUSt6TA/XYzVg3drzXI/AAAAAAAAPdE/n9KtXiFL55khq2wXnenPsWHoMFH8AQ8bQCEwYBhgL/s1600/Dagger%2Bwithout%2BReflection%2Band%2BDagger%2Bwith%2BReflection.png)

For more components, the difference might be greater. Imagine with multi modules and a lot of components each.

**Why and how?**  
Dagger doesn't really generate the dependencies at compile time. If we notice, instead of new instances coming out of the DaggerMyAwesomeAppComponent, it's just 2 methods:

```kotlin
//// Generated by Dagger's reflect-compiler. Do not modify!
...

public final class DaggerMyAwesomeAppComponent {
  private DaggerPocketTreasureComponent() {
    throw new AssertionError();
  }

  public static MyAwesomeAppComponent create() {
    return DaggerReflect.create(MyAwesomeAppComponent.class);
  }

  public static MyAwesomeAppComponent.Factory factory() {
    return DaggerReflect.factory(MyAwesomeAppComponent.Factory.class);
  }
}
```

Some words about Proguard: You should apply Proguard rules, when full reflection is applied. But I'm not yet in production using Dagger-Reflect because I think it's to early. The current version is still 0.1.0.

**Conclusion**  
As a code generation at compile time fan, i just jumped to code generation at runtime fan. I'm really interested to know how this kind of projects work. I have already forked Dagger2 in github and I hope I find some free time to study how it is done.

Best of luck!Â  ðŸ’ªðŸ’ªðŸ’ª

Stavro Xhardha
